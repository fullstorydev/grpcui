// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package main

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// KitchenSinkClient is the client API for KitchenSink service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KitchenSinkClient interface {
	// Ping is a no-op method, usable to test that a given channel works. No data is exchanged.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// The Exchange method can be useful for testing the UI. It's complicated request type
	// exercises many of the feature in gRPC UI's request form building code. The server will
	// echo back in response metadata all request metadata values it receives. If the metadata
	// key ends with "-t", it is sent back as trailer metadata. Otherwise, it is sent back as
	// header metadata. The response will be the same as the request.
	Exchange(ctx context.Context, in *TestMessage, opts ...grpc.CallOption) (*TestMessage, error)
	// The UploadMany method is like Exchange, except that it is for testing RPCs that accept
	// a stream from the client. The server will reply with the last request message it
	// received, but with the needed_num_a field set to the number of messages observed. If
	// the client stream includes zero messages, the server will reply with an "Invalid
	// Argument" error code.
	UploadMany(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_UploadManyClient, error)
	// The DownloadMany method is like Exchange, except that it is for testing RPCs that have
	// a stream from the server. The value in the request for the numbers.needed_num_1 field
	// controls how many messages are included in the response stream. Each response sent is
	// a copy of the request.
	DownloadMany(ctx context.Context, in *TestMessage, opts ...grpc.CallOption) (KitchenSink_DownloadManyClient, error)
	// The DoManyThings method is like Exchange, except that it is for testing RPCs that
	// have bidirectional streams. The response stream will be a copy of the request
	// stream, so each request is mirrored to the response stream as it is received.
	DoManyThings(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_DoManyThingsClient, error)
	// Fail is useful for testing errors. The num_responses request field controls how many
	// response messages are sent before returning an error. The other request fields are
	// used to construct the error that will be returned.
	Fail(ctx context.Context, in *FailRequest, opts ...grpc.CallOption) (KitchenSink_FailClient, error)
	// SendTimestamp is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a timestamp.
	SendTimestamp(ctx context.Context, in *timestamppb.Timestamp, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendDuration is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a duration.
	SendDuration(ctx context.Context, in *durationpb.Duration, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendAny is for testing the UI web form, that it can construct a request
	// form that has only the single Any message input.
	SendAny(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendStruct is for testing the UI web form, that it can construct a request
	// form that has only the single, text area input for a JSON object.
	SendStruct(ctx context.Context, in *structpb.Struct, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendValue is for testing the UI web form, that it can construct a request
	// form that has only the single, text area input for a JSON value.
	SendValue(ctx context.Context, in *structpb.Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendListValue is for testing the UI web form, that it can construct a request
	// form that has just the input(s) for a JSON array.
	SendListValue(ctx context.Context, in *structpb.ListValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendBytes is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a bytes value.
	SendBytes(ctx context.Context, in *wrapperspb.BytesValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendString is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a string value.
	SendString(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendBool is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a boolean value.
	SendBool(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendDouble is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a double value.
	SendDouble(ctx context.Context, in *wrapperspb.DoubleValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendFloat is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a float value.
	SendFloat(ctx context.Context, in *wrapperspb.FloatValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendInt32 is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a signed 32-bit int value.
	SendInt32(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendInt64 is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a signed 64-bit int value.
	SendInt64(ctx context.Context, in *wrapperspb.Int64Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendUInt32 is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for an unsigned 32-bit int value.
	SendUInt32(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendUInt64 is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for an unsigned 64-bit int value.
	SendUInt64(ctx context.Context, in *wrapperspb.UInt64Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SendMultipleTimestamp(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleTimestampClient, error)
	SendMultipleDuration(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleDurationClient, error)
	SendMultipleAny(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleAnyClient, error)
	SendMultipleStruct(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleStructClient, error)
	SendMultipleValue(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleValueClient, error)
	SendMultipleListValue(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleListValueClient, error)
	SendMultipleBytes(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleBytesClient, error)
	SendMultipleString(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleStringClient, error)
	SendMultipleBool(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleBoolClient, error)
	SendMultipleDouble(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleDoubleClient, error)
	SendMultipleFloat(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleFloatClient, error)
	SendMultipleInt32(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleInt32Client, error)
	SendMultipleInt64(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleInt64Client, error)
	SendMultipleUInt32(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleUInt32Client, error)
	SendMultipleUInt64(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleUInt64Client, error)
}

type kitchenSinkClient struct {
	cc grpc.ClientConnInterface
}

func NewKitchenSinkClient(cc grpc.ClientConnInterface) KitchenSinkClient {
	return &kitchenSinkClient{cc}
}

func (c *kitchenSinkClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) Exchange(ctx context.Context, in *TestMessage, opts ...grpc.CallOption) (*TestMessage, error) {
	out := new(TestMessage)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/Exchange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) UploadMany(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_UploadManyClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[0], "/test.KitchenSink/UploadMany", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkUploadManyClient{stream}
	return x, nil
}

type KitchenSink_UploadManyClient interface {
	Send(*TestMessage) error
	CloseAndRecv() (*TestMessage, error)
	grpc.ClientStream
}

type kitchenSinkUploadManyClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkUploadManyClient) Send(m *TestMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkUploadManyClient) CloseAndRecv() (*TestMessage, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TestMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) DownloadMany(ctx context.Context, in *TestMessage, opts ...grpc.CallOption) (KitchenSink_DownloadManyClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[1], "/test.KitchenSink/DownloadMany", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkDownloadManyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KitchenSink_DownloadManyClient interface {
	Recv() (*TestMessage, error)
	grpc.ClientStream
}

type kitchenSinkDownloadManyClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkDownloadManyClient) Recv() (*TestMessage, error) {
	m := new(TestMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) DoManyThings(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_DoManyThingsClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[2], "/test.KitchenSink/DoManyThings", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkDoManyThingsClient{stream}
	return x, nil
}

type KitchenSink_DoManyThingsClient interface {
	Send(*TestMessage) error
	Recv() (*TestMessage, error)
	grpc.ClientStream
}

type kitchenSinkDoManyThingsClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkDoManyThingsClient) Send(m *TestMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkDoManyThingsClient) Recv() (*TestMessage, error) {
	m := new(TestMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) Fail(ctx context.Context, in *FailRequest, opts ...grpc.CallOption) (KitchenSink_FailClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[3], "/test.KitchenSink/Fail", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkFailClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KitchenSink_FailClient interface {
	Recv() (*TestMessage, error)
	grpc.ClientStream
}

type kitchenSinkFailClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkFailClient) Recv() (*TestMessage, error) {
	m := new(TestMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendTimestamp(ctx context.Context, in *timestamppb.Timestamp, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendTimestamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendDuration(ctx context.Context, in *durationpb.Duration, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendDuration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendAny(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendAny", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendStruct(ctx context.Context, in *structpb.Struct, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendValue(ctx context.Context, in *structpb.Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendListValue(ctx context.Context, in *structpb.ListValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendListValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendBytes(ctx context.Context, in *wrapperspb.BytesValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendBytes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendString(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendBool(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendDouble(ctx context.Context, in *wrapperspb.DoubleValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendDouble", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendFloat(ctx context.Context, in *wrapperspb.FloatValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendFloat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendInt32(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendInt32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendInt64(ctx context.Context, in *wrapperspb.Int64Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendInt64", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendUInt32(ctx context.Context, in *wrapperspb.UInt32Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendUInt32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendUInt64(ctx context.Context, in *wrapperspb.UInt64Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/test.KitchenSink/SendUInt64", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kitchenSinkClient) SendMultipleTimestamp(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleTimestampClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[4], "/test.KitchenSink/SendMultipleTimestamp", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleTimestampClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleTimestampClient interface {
	Send(*timestamppb.Timestamp) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleTimestampClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleTimestampClient) Send(m *timestamppb.Timestamp) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleTimestampClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleDuration(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleDurationClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[5], "/test.KitchenSink/SendMultipleDuration", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleDurationClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleDurationClient interface {
	Send(*durationpb.Duration) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleDurationClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleDurationClient) Send(m *durationpb.Duration) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleDurationClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleAny(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleAnyClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[6], "/test.KitchenSink/SendMultipleAny", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleAnyClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleAnyClient interface {
	Send(*anypb.Any) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleAnyClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleAnyClient) Send(m *anypb.Any) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleAnyClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleStruct(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleStructClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[7], "/test.KitchenSink/SendMultipleStruct", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleStructClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleStructClient interface {
	Send(*structpb.Struct) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleStructClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleStructClient) Send(m *structpb.Struct) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleStructClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleValue(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleValueClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[8], "/test.KitchenSink/SendMultipleValue", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleValueClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleValueClient interface {
	Send(*structpb.Value) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleValueClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleValueClient) Send(m *structpb.Value) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleValueClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleListValue(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleListValueClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[9], "/test.KitchenSink/SendMultipleListValue", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleListValueClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleListValueClient interface {
	Send(*structpb.ListValue) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleListValueClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleListValueClient) Send(m *structpb.ListValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleListValueClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleBytes(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleBytesClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[10], "/test.KitchenSink/SendMultipleBytes", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleBytesClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleBytesClient interface {
	Send(*wrapperspb.BytesValue) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleBytesClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleBytesClient) Send(m *wrapperspb.BytesValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleBytesClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleString(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleStringClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[11], "/test.KitchenSink/SendMultipleString", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleStringClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleStringClient interface {
	Send(*wrapperspb.StringValue) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleStringClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleStringClient) Send(m *wrapperspb.StringValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleStringClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleBool(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleBoolClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[12], "/test.KitchenSink/SendMultipleBool", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleBoolClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleBoolClient interface {
	Send(*wrapperspb.BoolValue) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleBoolClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleBoolClient) Send(m *wrapperspb.BoolValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleBoolClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleDouble(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleDoubleClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[13], "/test.KitchenSink/SendMultipleDouble", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleDoubleClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleDoubleClient interface {
	Send(*wrapperspb.DoubleValue) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleDoubleClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleDoubleClient) Send(m *wrapperspb.DoubleValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleDoubleClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleFloat(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleFloatClient, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[14], "/test.KitchenSink/SendMultipleFloat", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleFloatClient{stream}
	return x, nil
}

type KitchenSink_SendMultipleFloatClient interface {
	Send(*wrapperspb.FloatValue) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleFloatClient struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleFloatClient) Send(m *wrapperspb.FloatValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleFloatClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleInt32(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleInt32Client, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[15], "/test.KitchenSink/SendMultipleInt32", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleInt32Client{stream}
	return x, nil
}

type KitchenSink_SendMultipleInt32Client interface {
	Send(*wrapperspb.Int32Value) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleInt32Client struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleInt32Client) Send(m *wrapperspb.Int32Value) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleInt32Client) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleInt64(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleInt64Client, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[16], "/test.KitchenSink/SendMultipleInt64", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleInt64Client{stream}
	return x, nil
}

type KitchenSink_SendMultipleInt64Client interface {
	Send(*wrapperspb.Int64Value) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleInt64Client struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleInt64Client) Send(m *wrapperspb.Int64Value) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleInt64Client) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleUInt32(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleUInt32Client, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[17], "/test.KitchenSink/SendMultipleUInt32", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleUInt32Client{stream}
	return x, nil
}

type KitchenSink_SendMultipleUInt32Client interface {
	Send(*wrapperspb.UInt32Value) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleUInt32Client struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleUInt32Client) Send(m *wrapperspb.UInt32Value) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleUInt32Client) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kitchenSinkClient) SendMultipleUInt64(ctx context.Context, opts ...grpc.CallOption) (KitchenSink_SendMultipleUInt64Client, error) {
	stream, err := c.cc.NewStream(ctx, &KitchenSink_ServiceDesc.Streams[18], "/test.KitchenSink/SendMultipleUInt64", opts...)
	if err != nil {
		return nil, err
	}
	x := &kitchenSinkSendMultipleUInt64Client{stream}
	return x, nil
}

type KitchenSink_SendMultipleUInt64Client interface {
	Send(*wrapperspb.UInt64Value) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kitchenSinkSendMultipleUInt64Client struct {
	grpc.ClientStream
}

func (x *kitchenSinkSendMultipleUInt64Client) Send(m *wrapperspb.UInt64Value) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleUInt64Client) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KitchenSinkServer is the server API for KitchenSink service.
// All implementations must embed UnimplementedKitchenSinkServer
// for forward compatibility
type KitchenSinkServer interface {
	// Ping is a no-op method, usable to test that a given channel works. No data is exchanged.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// The Exchange method can be useful for testing the UI. It's complicated request type
	// exercises many of the feature in gRPC UI's request form building code. The server will
	// echo back in response metadata all request metadata values it receives. If the metadata
	// key ends with "-t", it is sent back as trailer metadata. Otherwise, it is sent back as
	// header metadata. The response will be the same as the request.
	Exchange(context.Context, *TestMessage) (*TestMessage, error)
	// The UploadMany method is like Exchange, except that it is for testing RPCs that accept
	// a stream from the client. The server will reply with the last request message it
	// received, but with the needed_num_a field set to the number of messages observed. If
	// the client stream includes zero messages, the server will reply with an "Invalid
	// Argument" error code.
	UploadMany(KitchenSink_UploadManyServer) error
	// The DownloadMany method is like Exchange, except that it is for testing RPCs that have
	// a stream from the server. The value in the request for the numbers.needed_num_1 field
	// controls how many messages are included in the response stream. Each response sent is
	// a copy of the request.
	DownloadMany(*TestMessage, KitchenSink_DownloadManyServer) error
	// The DoManyThings method is like Exchange, except that it is for testing RPCs that
	// have bidirectional streams. The response stream will be a copy of the request
	// stream, so each request is mirrored to the response stream as it is received.
	DoManyThings(KitchenSink_DoManyThingsServer) error
	// Fail is useful for testing errors. The num_responses request field controls how many
	// response messages are sent before returning an error. The other request fields are
	// used to construct the error that will be returned.
	Fail(*FailRequest, KitchenSink_FailServer) error
	// SendTimestamp is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a timestamp.
	SendTimestamp(context.Context, *timestamppb.Timestamp) (*emptypb.Empty, error)
	// SendDuration is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a duration.
	SendDuration(context.Context, *durationpb.Duration) (*emptypb.Empty, error)
	// SendAny is for testing the UI web form, that it can construct a request
	// form that has only the single Any message input.
	SendAny(context.Context, *anypb.Any) (*emptypb.Empty, error)
	// SendStruct is for testing the UI web form, that it can construct a request
	// form that has only the single, text area input for a JSON object.
	SendStruct(context.Context, *structpb.Struct) (*emptypb.Empty, error)
	// SendValue is for testing the UI web form, that it can construct a request
	// form that has only the single, text area input for a JSON value.
	SendValue(context.Context, *structpb.Value) (*emptypb.Empty, error)
	// SendListValue is for testing the UI web form, that it can construct a request
	// form that has just the input(s) for a JSON array.
	SendListValue(context.Context, *structpb.ListValue) (*emptypb.Empty, error)
	// SendBytes is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a bytes value.
	SendBytes(context.Context, *wrapperspb.BytesValue) (*emptypb.Empty, error)
	// SendString is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a string value.
	SendString(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	// SendBool is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a boolean value.
	SendBool(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	// SendDouble is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a double value.
	SendDouble(context.Context, *wrapperspb.DoubleValue) (*emptypb.Empty, error)
	// SendFloat is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a float value.
	SendFloat(context.Context, *wrapperspb.FloatValue) (*emptypb.Empty, error)
	// SendInt32 is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a signed 32-bit int value.
	SendInt32(context.Context, *wrapperspb.Int32Value) (*emptypb.Empty, error)
	// SendInt64 is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for a signed 64-bit int value.
	SendInt64(context.Context, *wrapperspb.Int64Value) (*emptypb.Empty, error)
	// SendUInt32 is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for an unsigned 32-bit int value.
	SendUInt32(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error)
	// SendUInt64 is for testing the UI web form, that it can construct a request
	// form that has only the single scalar input for an unsigned 64-bit int value.
	SendUInt64(context.Context, *wrapperspb.UInt64Value) (*emptypb.Empty, error)
	SendMultipleTimestamp(KitchenSink_SendMultipleTimestampServer) error
	SendMultipleDuration(KitchenSink_SendMultipleDurationServer) error
	SendMultipleAny(KitchenSink_SendMultipleAnyServer) error
	SendMultipleStruct(KitchenSink_SendMultipleStructServer) error
	SendMultipleValue(KitchenSink_SendMultipleValueServer) error
	SendMultipleListValue(KitchenSink_SendMultipleListValueServer) error
	SendMultipleBytes(KitchenSink_SendMultipleBytesServer) error
	SendMultipleString(KitchenSink_SendMultipleStringServer) error
	SendMultipleBool(KitchenSink_SendMultipleBoolServer) error
	SendMultipleDouble(KitchenSink_SendMultipleDoubleServer) error
	SendMultipleFloat(KitchenSink_SendMultipleFloatServer) error
	SendMultipleInt32(KitchenSink_SendMultipleInt32Server) error
	SendMultipleInt64(KitchenSink_SendMultipleInt64Server) error
	SendMultipleUInt32(KitchenSink_SendMultipleUInt32Server) error
	SendMultipleUInt64(KitchenSink_SendMultipleUInt64Server) error
	mustEmbedUnimplementedKitchenSinkServer()
}

// UnimplementedKitchenSinkServer must be embedded to have forward compatible implementations.
type UnimplementedKitchenSinkServer struct {
}

func (UnimplementedKitchenSinkServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedKitchenSinkServer) Exchange(context.Context, *TestMessage) (*TestMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exchange not implemented")
}
func (UnimplementedKitchenSinkServer) UploadMany(KitchenSink_UploadManyServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadMany not implemented")
}
func (UnimplementedKitchenSinkServer) DownloadMany(*TestMessage, KitchenSink_DownloadManyServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadMany not implemented")
}
func (UnimplementedKitchenSinkServer) DoManyThings(KitchenSink_DoManyThingsServer) error {
	return status.Errorf(codes.Unimplemented, "method DoManyThings not implemented")
}
func (UnimplementedKitchenSinkServer) Fail(*FailRequest, KitchenSink_FailServer) error {
	return status.Errorf(codes.Unimplemented, "method Fail not implemented")
}
func (UnimplementedKitchenSinkServer) SendTimestamp(context.Context, *timestamppb.Timestamp) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTimestamp not implemented")
}
func (UnimplementedKitchenSinkServer) SendDuration(context.Context, *durationpb.Duration) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendDuration not implemented")
}
func (UnimplementedKitchenSinkServer) SendAny(context.Context, *anypb.Any) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendAny not implemented")
}
func (UnimplementedKitchenSinkServer) SendStruct(context.Context, *structpb.Struct) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendStruct not implemented")
}
func (UnimplementedKitchenSinkServer) SendValue(context.Context, *structpb.Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendValue not implemented")
}
func (UnimplementedKitchenSinkServer) SendListValue(context.Context, *structpb.ListValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendListValue not implemented")
}
func (UnimplementedKitchenSinkServer) SendBytes(context.Context, *wrapperspb.BytesValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBytes not implemented")
}
func (UnimplementedKitchenSinkServer) SendString(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendString not implemented")
}
func (UnimplementedKitchenSinkServer) SendBool(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBool not implemented")
}
func (UnimplementedKitchenSinkServer) SendDouble(context.Context, *wrapperspb.DoubleValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendDouble not implemented")
}
func (UnimplementedKitchenSinkServer) SendFloat(context.Context, *wrapperspb.FloatValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendFloat not implemented")
}
func (UnimplementedKitchenSinkServer) SendInt32(context.Context, *wrapperspb.Int32Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendInt32 not implemented")
}
func (UnimplementedKitchenSinkServer) SendInt64(context.Context, *wrapperspb.Int64Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendInt64 not implemented")
}
func (UnimplementedKitchenSinkServer) SendUInt32(context.Context, *wrapperspb.UInt32Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendUInt32 not implemented")
}
func (UnimplementedKitchenSinkServer) SendUInt64(context.Context, *wrapperspb.UInt64Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendUInt64 not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleTimestamp(KitchenSink_SendMultipleTimestampServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleTimestamp not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleDuration(KitchenSink_SendMultipleDurationServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleDuration not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleAny(KitchenSink_SendMultipleAnyServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleAny not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleStruct(KitchenSink_SendMultipleStructServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleStruct not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleValue(KitchenSink_SendMultipleValueServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleValue not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleListValue(KitchenSink_SendMultipleListValueServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleListValue not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleBytes(KitchenSink_SendMultipleBytesServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleBytes not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleString(KitchenSink_SendMultipleStringServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleString not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleBool(KitchenSink_SendMultipleBoolServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleBool not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleDouble(KitchenSink_SendMultipleDoubleServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleDouble not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleFloat(KitchenSink_SendMultipleFloatServer) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleFloat not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleInt32(KitchenSink_SendMultipleInt32Server) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleInt32 not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleInt64(KitchenSink_SendMultipleInt64Server) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleInt64 not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleUInt32(KitchenSink_SendMultipleUInt32Server) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleUInt32 not implemented")
}
func (UnimplementedKitchenSinkServer) SendMultipleUInt64(KitchenSink_SendMultipleUInt64Server) error {
	return status.Errorf(codes.Unimplemented, "method SendMultipleUInt64 not implemented")
}
func (UnimplementedKitchenSinkServer) mustEmbedUnimplementedKitchenSinkServer() {}

// UnsafeKitchenSinkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KitchenSinkServer will
// result in compilation errors.
type UnsafeKitchenSinkServer interface {
	mustEmbedUnimplementedKitchenSinkServer()
}

func RegisterKitchenSinkServer(s grpc.ServiceRegistrar, srv KitchenSinkServer) {
	s.RegisterService(&KitchenSink_ServiceDesc, srv)
}

func _KitchenSink_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_Exchange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).Exchange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/Exchange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).Exchange(ctx, req.(*TestMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_UploadMany_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).UploadMany(&kitchenSinkUploadManyServer{stream})
}

type KitchenSink_UploadManyServer interface {
	SendAndClose(*TestMessage) error
	Recv() (*TestMessage, error)
	grpc.ServerStream
}

type kitchenSinkUploadManyServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkUploadManyServer) SendAndClose(m *TestMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkUploadManyServer) Recv() (*TestMessage, error) {
	m := new(TestMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_DownloadMany_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TestMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KitchenSinkServer).DownloadMany(m, &kitchenSinkDownloadManyServer{stream})
}

type KitchenSink_DownloadManyServer interface {
	Send(*TestMessage) error
	grpc.ServerStream
}

type kitchenSinkDownloadManyServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkDownloadManyServer) Send(m *TestMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _KitchenSink_DoManyThings_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).DoManyThings(&kitchenSinkDoManyThingsServer{stream})
}

type KitchenSink_DoManyThingsServer interface {
	Send(*TestMessage) error
	Recv() (*TestMessage, error)
	grpc.ServerStream
}

type kitchenSinkDoManyThingsServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkDoManyThingsServer) Send(m *TestMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkDoManyThingsServer) Recv() (*TestMessage, error) {
	m := new(TestMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_Fail_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FailRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KitchenSinkServer).Fail(m, &kitchenSinkFailServer{stream})
}

type KitchenSink_FailServer interface {
	Send(*TestMessage) error
	grpc.ServerStream
}

type kitchenSinkFailServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkFailServer) Send(m *TestMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _KitchenSink_SendTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(timestamppb.Timestamp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendTimestamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendTimestamp(ctx, req.(*timestamppb.Timestamp))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendDuration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(durationpb.Duration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendDuration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendDuration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendDuration(ctx, req.(*durationpb.Duration))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendAny_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(anypb.Any)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendAny(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendAny",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendAny(ctx, req.(*anypb.Any))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(structpb.Struct)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendStruct(ctx, req.(*structpb.Struct))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(structpb.Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendValue(ctx, req.(*structpb.Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendListValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(structpb.ListValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendListValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendListValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendListValue(ctx, req.(*structpb.ListValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BytesValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendBytes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendBytes(ctx, req.(*wrapperspb.BytesValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendString(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendBool(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendDouble_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.DoubleValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendDouble(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendDouble",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendDouble(ctx, req.(*wrapperspb.DoubleValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendFloat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.FloatValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendFloat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendFloat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendFloat(ctx, req.(*wrapperspb.FloatValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendInt32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.Int32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendInt32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendInt32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendInt32(ctx, req.(*wrapperspb.Int32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendInt64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.Int64Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendInt64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendInt64",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendInt64(ctx, req.(*wrapperspb.Int64Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendUInt32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.UInt32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendUInt32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendUInt32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendUInt32(ctx, req.(*wrapperspb.UInt32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendUInt64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.UInt64Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KitchenSinkServer).SendUInt64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/test.KitchenSink/SendUInt64",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KitchenSinkServer).SendUInt64(ctx, req.(*wrapperspb.UInt64Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _KitchenSink_SendMultipleTimestamp_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleTimestamp(&kitchenSinkSendMultipleTimestampServer{stream})
}

type KitchenSink_SendMultipleTimestampServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*timestamppb.Timestamp, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleTimestampServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleTimestampServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleTimestampServer) Recv() (*timestamppb.Timestamp, error) {
	m := new(timestamppb.Timestamp)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleDuration_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleDuration(&kitchenSinkSendMultipleDurationServer{stream})
}

type KitchenSink_SendMultipleDurationServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*durationpb.Duration, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleDurationServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleDurationServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleDurationServer) Recv() (*durationpb.Duration, error) {
	m := new(durationpb.Duration)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleAny_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleAny(&kitchenSinkSendMultipleAnyServer{stream})
}

type KitchenSink_SendMultipleAnyServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*anypb.Any, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleAnyServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleAnyServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleAnyServer) Recv() (*anypb.Any, error) {
	m := new(anypb.Any)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleStruct_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleStruct(&kitchenSinkSendMultipleStructServer{stream})
}

type KitchenSink_SendMultipleStructServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*structpb.Struct, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleStructServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleStructServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleStructServer) Recv() (*structpb.Struct, error) {
	m := new(structpb.Struct)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleValue_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleValue(&kitchenSinkSendMultipleValueServer{stream})
}

type KitchenSink_SendMultipleValueServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*structpb.Value, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleValueServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleValueServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleValueServer) Recv() (*structpb.Value, error) {
	m := new(structpb.Value)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleListValue_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleListValue(&kitchenSinkSendMultipleListValueServer{stream})
}

type KitchenSink_SendMultipleListValueServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*structpb.ListValue, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleListValueServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleListValueServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleListValueServer) Recv() (*structpb.ListValue, error) {
	m := new(structpb.ListValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleBytes_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleBytes(&kitchenSinkSendMultipleBytesServer{stream})
}

type KitchenSink_SendMultipleBytesServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.BytesValue, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleBytesServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleBytesServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleBytesServer) Recv() (*wrapperspb.BytesValue, error) {
	m := new(wrapperspb.BytesValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleString_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleString(&kitchenSinkSendMultipleStringServer{stream})
}

type KitchenSink_SendMultipleStringServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.StringValue, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleStringServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleStringServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleStringServer) Recv() (*wrapperspb.StringValue, error) {
	m := new(wrapperspb.StringValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleBool_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleBool(&kitchenSinkSendMultipleBoolServer{stream})
}

type KitchenSink_SendMultipleBoolServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.BoolValue, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleBoolServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleBoolServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleBoolServer) Recv() (*wrapperspb.BoolValue, error) {
	m := new(wrapperspb.BoolValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleDouble_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleDouble(&kitchenSinkSendMultipleDoubleServer{stream})
}

type KitchenSink_SendMultipleDoubleServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.DoubleValue, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleDoubleServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleDoubleServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleDoubleServer) Recv() (*wrapperspb.DoubleValue, error) {
	m := new(wrapperspb.DoubleValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleFloat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleFloat(&kitchenSinkSendMultipleFloatServer{stream})
}

type KitchenSink_SendMultipleFloatServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.FloatValue, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleFloatServer struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleFloatServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleFloatServer) Recv() (*wrapperspb.FloatValue, error) {
	m := new(wrapperspb.FloatValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleInt32_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleInt32(&kitchenSinkSendMultipleInt32Server{stream})
}

type KitchenSink_SendMultipleInt32Server interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.Int32Value, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleInt32Server struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleInt32Server) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleInt32Server) Recv() (*wrapperspb.Int32Value, error) {
	m := new(wrapperspb.Int32Value)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleInt64_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleInt64(&kitchenSinkSendMultipleInt64Server{stream})
}

type KitchenSink_SendMultipleInt64Server interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.Int64Value, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleInt64Server struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleInt64Server) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleInt64Server) Recv() (*wrapperspb.Int64Value, error) {
	m := new(wrapperspb.Int64Value)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleUInt32_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleUInt32(&kitchenSinkSendMultipleUInt32Server{stream})
}

type KitchenSink_SendMultipleUInt32Server interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.UInt32Value, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleUInt32Server struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleUInt32Server) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleUInt32Server) Recv() (*wrapperspb.UInt32Value, error) {
	m := new(wrapperspb.UInt32Value)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KitchenSink_SendMultipleUInt64_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KitchenSinkServer).SendMultipleUInt64(&kitchenSinkSendMultipleUInt64Server{stream})
}

type KitchenSink_SendMultipleUInt64Server interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.UInt64Value, error)
	grpc.ServerStream
}

type kitchenSinkSendMultipleUInt64Server struct {
	grpc.ServerStream
}

func (x *kitchenSinkSendMultipleUInt64Server) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kitchenSinkSendMultipleUInt64Server) Recv() (*wrapperspb.UInt64Value, error) {
	m := new(wrapperspb.UInt64Value)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KitchenSink_ServiceDesc is the grpc.ServiceDesc for KitchenSink service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KitchenSink_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "test.KitchenSink",
	HandlerType: (*KitchenSinkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _KitchenSink_Ping_Handler,
		},
		{
			MethodName: "Exchange",
			Handler:    _KitchenSink_Exchange_Handler,
		},
		{
			MethodName: "SendTimestamp",
			Handler:    _KitchenSink_SendTimestamp_Handler,
		},
		{
			MethodName: "SendDuration",
			Handler:    _KitchenSink_SendDuration_Handler,
		},
		{
			MethodName: "SendAny",
			Handler:    _KitchenSink_SendAny_Handler,
		},
		{
			MethodName: "SendStruct",
			Handler:    _KitchenSink_SendStruct_Handler,
		},
		{
			MethodName: "SendValue",
			Handler:    _KitchenSink_SendValue_Handler,
		},
		{
			MethodName: "SendListValue",
			Handler:    _KitchenSink_SendListValue_Handler,
		},
		{
			MethodName: "SendBytes",
			Handler:    _KitchenSink_SendBytes_Handler,
		},
		{
			MethodName: "SendString",
			Handler:    _KitchenSink_SendString_Handler,
		},
		{
			MethodName: "SendBool",
			Handler:    _KitchenSink_SendBool_Handler,
		},
		{
			MethodName: "SendDouble",
			Handler:    _KitchenSink_SendDouble_Handler,
		},
		{
			MethodName: "SendFloat",
			Handler:    _KitchenSink_SendFloat_Handler,
		},
		{
			MethodName: "SendInt32",
			Handler:    _KitchenSink_SendInt32_Handler,
		},
		{
			MethodName: "SendInt64",
			Handler:    _KitchenSink_SendInt64_Handler,
		},
		{
			MethodName: "SendUInt32",
			Handler:    _KitchenSink_SendUInt32_Handler,
		},
		{
			MethodName: "SendUInt64",
			Handler:    _KitchenSink_SendUInt64_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadMany",
			Handler:       _KitchenSink_UploadMany_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadMany",
			Handler:       _KitchenSink_DownloadMany_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DoManyThings",
			Handler:       _KitchenSink_DoManyThings_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Fail",
			Handler:       _KitchenSink_Fail_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SendMultipleTimestamp",
			Handler:       _KitchenSink_SendMultipleTimestamp_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleDuration",
			Handler:       _KitchenSink_SendMultipleDuration_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleAny",
			Handler:       _KitchenSink_SendMultipleAny_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleStruct",
			Handler:       _KitchenSink_SendMultipleStruct_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleValue",
			Handler:       _KitchenSink_SendMultipleValue_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleListValue",
			Handler:       _KitchenSink_SendMultipleListValue_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleBytes",
			Handler:       _KitchenSink_SendMultipleBytes_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleString",
			Handler:       _KitchenSink_SendMultipleString_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleBool",
			Handler:       _KitchenSink_SendMultipleBool_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleDouble",
			Handler:       _KitchenSink_SendMultipleDouble_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleFloat",
			Handler:       _KitchenSink_SendMultipleFloat_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleInt32",
			Handler:       _KitchenSink_SendMultipleInt32_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleInt64",
			Handler:       _KitchenSink_SendMultipleInt64_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleUInt32",
			Handler:       _KitchenSink_SendMultipleUInt32_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SendMultipleUInt64",
			Handler:       _KitchenSink_SendMultipleUInt64_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "test.proto",
}
